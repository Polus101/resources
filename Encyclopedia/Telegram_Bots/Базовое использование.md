# Телеграм боты (AIOgram)
AIOgram - самая популярная и проработанная библиотека на Python для написания телеграм ботов. Она асинхронная, а обработка событий происходит каждая в своей функции


## Стандартный начальный код
Если запустить этот простой код и ввести в боте команду `/start`, вам пришлется соощение `Привет! Это первое сообщение бота! Оно высвечивается, когда пользователь вводит команду /start`
```python
import asyncio

from aiogram import Bot, Dispatcher, F
from aiogram.types import Message

tg_bot_token = "ТОКЕН вашего телеграм бота"

dp = Dispatcher()


@dp.message(F.text=="/start")
async def command_start(message: Message) -> None:
    await message.answer("Привет! Это первое сообщение бота! Оно высвечивается, когда пользователь вводит команду /start")


async def main():
    bot = Bot(token=tg_bot_token)
    await dp.start_polling(bot)


if __name__ == "__main__":
    asyncio.run(main())
```
Разбираемся, что здесь происходит **(все это важно прочитать, осознать и запомнить)**:
1) `dp = Dispatcher()` - создание объекта класса `Dispatcher`. Это важная переменная - именно она на 90% автоматизированно управляет вашим боом. И и менно через нее вы будете обрабатывать различные действия пользователя. Например, нажатия кнопко, ввод команд или текста
2) `if __name__ == "__main__": asyncio.run(main())` - стандартный запуск асинхронной функции `main`
3) `async def main():` - стандартное определение функции `main`
4) `bot = Bot(token=tg_bot_token)` - создание объекта класса Bot. Его вы использовать будете не скоро - для базового функционала он не пригодится, но его обязательно необходимо создать, чтобы указать строчкой ниже в диспетчере
5) `await dp.start_polling(bot)` - запуск автоматического управления ботом
**Важная сноска** - под "автоматическим управлением" подразумевается, что диспетчер будет на готове. Он будет сидеть и ждать каких то действия пользователя, чтобы на них реагировать
6) `@dp.message(F.text=="/start")` - декоратор для функции `command_start_handler`. Таких декораторов у вас будет **очень** много в коде. 
Подобные этому декораторы делают так, чтобы функция запускалась автоматически, если какой то пользователь написал сообщение и его сообщение подпадает под условие в скобках `F.text=="/start"`. 
Такие функции называются **Хэндлеры (англ. handlers)**. Это функции, которые "перехватывают" (обрабатывают) сообщения или любые другие действия пользователя в боте
Здесь `F.text` - текст сообщения пользователя (F.text можно использовать **только** в декораторах)
7) `async def command_start(message: Message) -> None:` - определение асинхронной функции `command_start`. Вообще, почти все функции, связанные с aiogram буду асинхронные - привыкайте. Название функции, разумеется, можно дать любое.
В функция хэндлерах всегда будет аргумент. Конкретно эта функция в примере обрабатывает сообщение пользователя, поэтому аргумент резонно назвать `message`. В аргументе будет объект - сообщение пользователя. Попробуйте запринтить эту переменную в функции и увидите, что в ней хранится целая куча информации о самом сообщении (включая текст сообщения, **полную** информацию о пользователе, боте и чате)
Если вы проходили модуль "Расширяем знания Python", то вопросов возникнуть не должно
8) `await message.answer("Привет! Это первое сообщ...")` - вызов асинхронной функции answer из объека message. Выглядит странно, но через полученный аргумент message вы можете не только узнать, что было в сообщении пользователя, но вы так же можете и  отправлять ему сообщение в ответ. 
Именно это и делает эта функци - отправляет в ответ пользователю сообщение `Привет! Это первое ...`. Учтите, что принимает она только тип данных `string` - то есть текст

## Работа с объектом Message
Каждая функция хэндлер принимает один аргумент - то событие, которе произошло. Если мы обрабатываем текст сообщения, то функция хэндлер будет принимать соответственно сообщение

async def command_start(**message: Message**) -> None:

Здесь аргумент мы назвали `message` - по названию класса. В нем и будет лежать наш объект класса `Message`.
Попробуйте вывести эту переменную на экран - вы увидите всю информацию, которая в ней хранится. Но вот на основные поля, которые вам точно понадобятся:
### Поля
##### Текст сообщения пользователя 
```python
message.text
```

##### Вся открытая информация о пользователе, который прислал сообщение
```python
message.from_user
```

##### id пользователя, который прислал сообщение
```python
message.from_user.id
```

##### id сообщения, которое прислал пользователь
```python
message.message_id
```

### Функции
##### Отправка сообщения
```python
await message.answer("Текст сообщения")
```

##### Отправка ответного сообщение (reply)
```python
await message.reply("Текст сообщения")
```

##### Удаление сообщения
```python
await message.delete()
```

## Хэндлеры и фильтры
Как мы разобрались выше, функции хэндлеры перехватывают (обрабатывают) действия пользователя в боте. Хэндлер из стандартного примера кода обрабатывал сообщение `/start`. Условие срабатывания, указанное в декораторе `@dp.message(УСЛОВИЕ)` называется фильтром
*P.S. Здесь указаны только базовые. Фильтры для определения нажатий кнопок и прочего в дальнейших статьях*

### Фильтрация команд
Если мы хотим обрабатывать еще и команду `/moy_tg_bot_krutoy`, например, то достаточно просто добавить еще одну функцию хэндлер, которая будет обрабатывать нашу новую команду
```python
@dp.message(F.text=="/moy_tg_bot_krutoy")
async def command_start(message: Message) -> None:
    await message.answer("Этот бот очень очень крутой!")
```
*P.S. в aiogram есть отдельные фильтры для определения команд, но для базового использования будет удобнее и понятнее F.text*

### Фильтрация текста
Если мы хотим обрабатывать какое то текстовое сообщение пользователя (не команду), то код будет точно такой же

```python
@dp.message(F.text=="Привет")
async def command_start(message: Message) -> None:
    await message.answer("Пока")
```
Этот код реагирует на сообщение *Привет* от пользователя. И в ответ ему присылает сообщение *Пока*

### Фильтрация начала текста (если сообщение начинается с какого то текста)
Допустим, мы хотим написать функцию, которая будет срабатывать каждый раз, когда пользователь начинает свое сообщение со слова `Посчитай`. Для этого мы можем в фильтре применить функцию `startswith()`

```python
@dp.message(F.text.startswith("Посчитай"))
async def command_start(message: Message) -> None:
    splited_message_text = message.text.split(" ")
    number1 = int(splited_message_text[1])
    number2 = int(splited_message_text[2])
    await message.answer(str(number1+number2))
```
Данная функция будет срабатывать, когда пользователь пишет сообщение `Посчитай ...`. Если пользователь введет сообщение `Посчитай 10 5`, то функция сработает. В самой функции код разобьет текст сообщения пользователя по пробелам. Далее получит первое и второе число пользователя. И отправит пользователю в ответ сумму чисел. 


## Меню команд
Возможно, в некоторых телеграм ботах вы видели нечто подобное:
<p align="center">
<img src="https://github.com/Polus101/resources/blob/master/Encyclopedia/Telegram_Bots/img/commands_menu.png" style="width:30%"/>
</p>

Такое меню нужно, чтобы пользователь знал, какие команды есть в боте и что они делают. К тому же, при нажатии на команду и меню, она автоматически отправляется в чат, так что пользователю даже не приходится ее вводить

Сделать такое меню просто:
1) Добавьте импорт `from aiogram.types import BotCommand`
2) Создайте в файле `main` функцию, в которой пропишите в списке все команды. Функция должна принимать вашу переменную `bot`.
```python
async def set_commands_menu(bot):
    bot_commands = [
        BotCommand(command="/start", description="Запуск!"),
        BotCommand(command="/help", description="Получить справку по работе с ботом"),
        BotCommand(command="/donat", description="Поддержать автора"),
    ]
    await bot.set_my_commands(bot_commands)
```
Здесь в список кладутся экземпляры класса `BotCommand`, который мы импортировали на шаге 1. Он принимает 2 аргумента:
Первый - это сама команда
Второй - описание команды. Тот текст, который будет отображаться рядом с ней в меню
3) В функции `main` вызовите свою функцию `set_commands_menu`
```python
async def main():
    bot = Bot(token=tg_bot_token)
    # НАША ФУНКЦИЯ, КОТОРАЯ ЗАДАЕТ МЕНЮ БОТА
    await set_commands_menu(bot)
    # ^^^^^^^^^^^^^^^^^^^^^^^^
    await dp.start_polling(bot)
```

**P.S. Вы можете сделать функцию еще более универсальной, передавая ей аргумент bot_commands. А саму переменную можете определять, например, в файле config.py.** Тогда редактирование списка команд станет еще проще - не придется даже лезть в `main.py`

#### Для ленивых
Или можете просто прямо в функции main прописать все:
```python
async def main():
    bot = Bot(token=tg_bot_token)
    bot_commands = [
        BotCommand(command="/start", description="Запуск!"),
        BotCommand(command="/help", description="Получить справку по работе с ботом"),
        BotCommand(command="/donat", description="Поддержать автора"),
    ]
    await bot.set_my_commands(bot_commands)
    await dp.start_polling(bot)
```
Работать будет, разумеется, так же, но такой подход захламляет основную функцию main, что не очень хорошо. Далее в ней будут вызовы и других функций библиотеки, так что лучше держать ее чистой