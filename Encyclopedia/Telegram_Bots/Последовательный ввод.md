# Последовательный ввод (FSM)

Если Вы задумывались о том, как последовательно спросить у пользователя, например, сначала имя, а затем возраст, то, вероятно, решение даннной задачи никак не могло прийти Вам в голову

Действительно при разработке телеграм ботов решение такое несложной на первый взгляд задачи является совершенно неочевидным. 

Каждое действие пользователя здесь - отдельная функция, которая срабатывает по какому то фильтру. Например, если сообщение пользователя начинается с текста "Мой возраст: ". Такие фильтры уже освещались в прошлых статьях

**Однако, нам нужно задать четкое правило, что первое сообщение пользователя будет просто имя. А следующее сообщение пользователя будет просто возраст.** 
И для этого необходимо использовать `состояния`

`FSM - Finite State Machine.` Это нативный (встроенный) в библиотеку aiogram инструмент для работы с состояниями пользователя
_Однако, можно использовать для этих целей и базу данных_

## Что такое FSM

## Принцип работы
Принцип работы последовательного ввода понятнее всего будет объяснить схемой
<p align="center">
<img src="https://github.com/Polus101/resources/blob/master/Encyclopedia/Telegram_Bots/img/algorithm.png" style="width:90%"/>
</p>

Но для лучшего понимания рассмотрите пример кода ниже и его объяснение. Настоятельно рекомендуется скопировать его себе и потестировать

## Пример

```python
# Ваши предыдущие импорты
# Новые импорты
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.context import FSMContext

# Ваши переменные bot и token
# Небольшое изменение dp
dp = Dispatcher(storage=MemoryStorage())

# Определяем, какие состояния будут у пользователей
class States(StatesGroup):
    waiting_name = State()
    waiting_age = State()


@dp.message(F.text=='/start')
async def start_command(message: Message, state: FSMContext):
    await message.answer("Введите имя")
    # Устанавливаем состояние на ожидание имени
    await state.set_state(States.waiting_name)

# Здесь фильтр будет срабатывать на любое сообщение пользователя,
# если его состояние waiting_name
@dp.message(States.waiting_name)
async def process_name(message: Message, state: FSMContext):
    # В сообщении пользователя содержится его имя. Можно проверить, что он не написал
    # белиберду и сохранить имя, например, в БД
    await message.answer(f"Приятно познакомиться, {message.text}!")
    await message.answer(f"Сколько тебе лет?")
    # Устанавливаем состояние на ожидание возраста
    await state.set_state(States.waiting_age)

# Здесь фильтр будет срабатывать на любое сообщение пользователя,
# если его состояние waiting_age
@dp.message(States.waiting_age)
async def process_age(message: Message, state: FSMContext):
    # В сообщении пользователя содержится его возраст. Можно проверить, что он не написал
    # белиберду и сохранить возраст, например, в БД
    await message.answer(f"Регистрация в боте завершена!")
    # Сбрасываем состояние
    await state.clear()  


# Ваша функция main и ее запуск
```

Как видно из примера, изменений немного:
1) В определение объекта класса `Dispatcher` указать `storage` - хранилище данных о пользователях
2) Создать свой класс, который необходимо унаследовать от класса `StatesGroup`
3) В нем определить по переменной (объекту класса `State` для каждого состояния, которое будет у пользователя)
4) В нужный момент установить состояние пользователю `await state.set_state(States.waiting_name)` - таким образом сказав, что мы ожидаем следующим сообщением от этого пользователя его имя
5) Написать функцию хендлер с фильтром `States.waiting_name`. Сказав таким образом, что функция будет срабатывать на первое сообщение пользователя у которого текущее состояние `waiting_name`
6) Сбросить состояние пользователю после окончания работы с последовательным вводом `await state.clear()`

## Хранение данных
FSM так же умеет хранить временные данные. Чтобы не записывать в БД данные последовательно в каждом хэндлере, можно сначала сохранить их во временное хранилище. А когда пользователь введет все необходимые данные, уже записать их в БД

#### Запись данных во временное хранилище FSM
Шаблонный код простой
`await state.update_data(variable=value)`
Здесь `varable` - название временной переменной, `value` - значение
Намеример:
```python
await state.update_data(name=message.text)
```
Этот пример запишет во временную переменную FSM `name` текст сообщения пользователя

#### Чтение данных из временного хранилища FSM
Шаблонный код
`temp_data = await state.get_data()`
Здесь в переменную `temp_data` запишется словарь со всеми временными переменными
Достать каждую переменную из словаря можно по ключу
`print(temp_data['variable'])`
Намеример:
```python
temp_data = await state.get_data()
print(temp_data['name'])
```
Этот пример выведет на экран временную переменную `name`


### Дополним хэндлеры из предыдущего примера
```python
# Здесь фильтр будет срабатывать на любое сообщение пользователя,
# если его состояние waiting_name
@dp.message(States.waiting_name)
async def process_name(message: Message, state: FSMContext):
    # В сообщении пользователя содержится его имя. Можно проверить, что он не написал
    # белиберду
    await message.answer(f"Приятно познакомиться, {message.text}!")
    await message.answer(f"Сколько тебе лет?")
    # СОХРАНЯЕМ ВО ВРЕМЕННУЮ ПЕРЕМЕННУЮ name введенное им имя
    await state.update_data(name=message.text)
    # Устанавливаем состояние на ожидание возраста
    await state.set_state(States.waiting_age)

# Здесь фильтр будет срабатывать на любое сообщение пользователя,
# если его состояние waiting_age
@dp.message(States.waiting_age)
async def process_age(message: Message, state: FSMContext):
    # ЧИТАЕМ ВРЕМЕННЫЕ ДАННЫЕ и сохраняем их в temp_data
    temp_data = await state.get_data()
    # В сообщении пользователя содержится его возраст. Можно проверить, что он не написал
    # белиберду и сохранить сразу имя и возраст, например, в БД
    await message.answer(f"{temp_data['name']}, поздравляем с успешной регистрацией!")
    # Сбрасываем состояние
    await state.clear()  
```
