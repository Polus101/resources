# Последовательный ввод (FSM)

Если Вы задумывались о том, как последовательно спросить у пользователя, например, сначала имя, а затем возраст, то, вероятно, решение даннной задачи никак не могло прийти Вам в голову

Действительно при разработке телеграм ботов решение такое несложной на первый взгляд задачи является совершенно неочевидным. 

Каждое действие пользователя здесь - отдельная функция, которая срабатывает по какому то фильтру. Например, если сообщение пользователя начинается с текста "Мой возраст: ". Такие фильтры уже освещались в прошлых статьях

**Однако, нам нужно задать четкое правило, что первое сообщение пользователя будет просто имя. А следующее сообщение пользователя будет просто возраст.** 
И для этого необходимо использовать `состояния`

`FSM - Finite State Machine.` Это нативный (встроенный) в библиотеку aiogram инструмент для работы с состояниями пользователя
_Однако, можно использовать для этих целей и базу данных_

## Что такое FSM

## Принцип работы
Принцип работы последовательного ввода понятнее всего будет объяснить схемой
<p align="center">
<img src="https://github.com/Polus101/resources/blob/master/Encyclopedia/Telegram_Bots/img/algorithm.png" style="width:90%"/>
</p>

Но для лучшего понимания рассмотрите пример кода ниже и его объяснение. Настоятельно рекомендуется скопировать его себе и потестировать

## Пример

```python
# Ваши предыдущие импорты
# Новые импорты
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.context import FSMContext

# Ваши переменные bot и token
# Небольшое изменение dp
dp = Dispatcher(storage=MemoryStorage())

# Определяем, какие состояния будут у пользователей
class States(StatesGroup):
    waiting_name = State()
    waiting_age = State()


@dp.message(F.text=='/start')
async def start_command(message: Message, state: FSMContext):
    await message.answer("Введите имя")
    # Устанавливаем состояние на ожидание имени
    await state.set_state(States.waiting_name)

# Здесь фильтр будет срабатывать на любое сообщение пользователя,
# если его состояние waiting_name
@dp.message(States.waiting_name)
async def process_name(message: Message, state: FSMContext):
    # В сообщении пользователя содержится его имя. Можно проверить, что он не написал
    # белиберду и сохранить имя, например, в БД
    await message.answer(f"Приятно познакомиться, {message.text}!")
    await message.answer(f"Сколько тебе лет?")
    # Устанавливаем состояние на ожидание возраста
    await state.set_state(States.waiting_age)

# Здесь фильтр будет срабатывать на любое сообщение пользователя,
# если его состояние waiting_age
@dp.message(States.waiting_age)
async def process_age(message: Message, state: FSMContext):
    # В сообщении пользователя содержится его возраст. Можно проверить, что он не написал
    # белиберду и сохранить возраст, например, в БД
    await message.answer(f"Регистрация в боте завершена!")
    # Сбрасываем состояние
    await state.clear()  


# Ваша функция main и ее запуск
```

Как видно из примера, изменений немного:
1) В определение объекта класса `Dispatcher` указать `storage` - хранилище данных о пользователях
2) Создать свой класс, который необходимо унаследовать от класса `StatesGroup`
3) В нем определить по переменной (объекту класса `State` для каждого состояния, которое будет у пользователя)
4) В нужный момент установить состояние пользователю `await state.set_state(States.waiting_name)` - таким образом сказав, что мы ожидаем следующим сообщением от этого пользователя его имя
5) Написать функцию хендлер с фильтром `States.waiting_name`. Сказав таким образом, что функция будет срабатывать на первое сообщение пользователя у которого текущее состояние `waiting_name`
6) Сбросить состояние пользователю после окончания работы с последовательным вводом `await state.clear()`

## Подводные камни
### Важно для тех, кто хочет писать серьезных ботов
Как говорилось выше, `FSM` - просто переменная в коде. А значит, она неизбежно сбрасывается после перезапуска бота. Отсюда один главный недостаток - **использование FSM может быть небезопасным**

Если вы хотите, например, обновить бота на новую версию, Вам в любом случае необходимо его перезапустить. Если хотите баг исправить, если сервер, на котором располагается бот, лег на 5 минут, если технические работы на сервере и т.д. Есть множесто ситуация, когда придется ненадолго остановить бота
Что если в этот момент кто то из пользователей что то последовательно вводит? **Весь его прогресс сбросится**

А если он вводит данные для оплаты? Или `state` должен отслеживать процесс этой самой оплаты?

Пусть, оплату можно настроить и без использования состояний, **но даже с неважными** последовательными вводами есть беды для пользователя

**Рассмотрите несколько схем:**

<p align="center">
<img src="https://github.com/Polus101/resources/blob/master/Encyclopedia/Telegram_Bots/img/error_1.png" style="width:60%"/>
</p>

- Бот по какой то причине остановился после сохранения данных в бд. 
- Сброс `state` и вывод сообщения об успешной регистрации c кнопками главного меню пользователю не сработали (`state` все равно обнулится при повторном запуске)

Когда бот снова будет запущен, пользователь не поймет, пройдена ли регистрация, а кнопки главного меню для него так и не появятся. 
Более того, пользователь даже не узнает, когда именно бот снова начнет работать - ведь для него бот так и останется пустым, пока он снова не пропишет `/start` (хотя этого можно избежать, если оповещать всех пользователей о старте бота)


<p align="center">
<img src="https://github.com/Polus101/resources/blob/master/Encyclopedia/Telegram_Bots/img/error_2.png" style="width:60%"/>
</p>

Если бот остановится между сбросом `state` и выводом сообщения ситуация будет идентичная (так как `state` все равно обнулится при повторном запуске - эта сточка здесь не играет роли)

Окей, кажется, будто проблема решается, если поменять местами сохранение данных в БД и вывод сообщения с клавиатурой


<p align="center">
<img src="https://github.com/Polus101/resources/blob/master/Encyclopedia/Telegram_Bots/img/error_3.png" style="width:60%"/>
</p>


Однако тогда ситуация станет еще хуже. В прошлом примере пользователь мог додуматься снова ввести `/start`, а тут:
- Бот по какой то причине остановился после вывода сообщения пользователю об успешной регистрации с кнопками главного меню. 
- Сброс `state` не принципиален (`state` все равно обнулится при повторном запуске)
- Сохранение данных об имени в БД не сработало

Когда бот снова будет запущен, перед пользователем будет продолжать висеть главное меню и сообщение об успешной регистрации. 
Однако пользоваться ботом он не сможет - в БД нет записи об этом пользователе. БОльшая часть функций отвалится, либо будет работать некорректно, так как завязаны на БД


### Очевидное решение
**Не пользоваться `FSM` в важных боевых ботах.** 
Для хранения информации о состоянии пользователя можно использовать БД. Алгоритм работы хэндлеров будет точно **такой же**
Только фильтры станут чуть больше (но это зависит от выбранной БД)

А внутрення работа в хэндлере будет выглядеть следующим образом:

<p align="center">
<img src="https://github.com/Polus101/resources/blob/master/Encyclopedia/Telegram_Bots/img/error_4.png" style="width:60%"/>
</p>

Теперь, состояние пользователя будет храниться в БД, а **(запись данных в бд и обнуление state - последнее действие в функции)** При возникновении сбоя, после запуска бота мы получим на первый взгляд ужасную ситуацию:
- Сообщение отправлено, главное меню появилось
- State в БД все еще стоит на ожидание имени
- Данных об имени в БД нет

Пользователь думает, что регистрация завершена, видит главное меню. Но пользоваться ботом не может, так как бот думает, что следующее действие пользователя - ввод имени

#### Но теперь есть контроль
- Мы можем дополнительно первым делом в функции хэндлер поставить состояние `в процессе обработки введенного имени`
- И первым делом при старте бота "вручную" дообработать функции, которые оборвались на середине из за сбоя

Тогда схема будет следующая:

<p align="center">
<img src="https://github.com/Polus101/resources/blob/master/Encyclopedia/Telegram_Bots/img/error_5.png" style="width:80%"/>
</p>

При таком подходе в худшем случае после сбоя пользователь просто получит дубликат сообщения `"Регистрация завершена"` и увидит все те же кнопки главного меню
**P.S. реальный код будет сильно разниться в зависимости от выбранной БД и названий состояний**, но общая суть останется прежней